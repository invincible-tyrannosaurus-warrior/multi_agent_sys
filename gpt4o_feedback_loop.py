import os
import requests
import subprocess
import sys
import time
from GLM4_5V_call import analyze_image_with_glm45v

# --- CONFIG ---
API_URL = os.getenv("AZURE_API_URL", "https://meuw-eval-inst01-sb-oai.openai.azure.com/openai/deployments/gpt-4o/chat/completions?api-version=2024-10-21")
API_KEY = os.getenv("AZURE_API_KEY", "api key for got4o")
HEADERS = {"Content-Type": "application/json", "api-key": API_KEY}


# generated by GLM4.5V (分析上传录屏)
CODING_PROMPT = """
You are a coding expert. Your task is to use 'playwright' to write a python file that satisfies the following steps. 
1. Start at the Autoliv portal page (URL: xxx). 注！不要对这一步进行截图和源码下载，直接进行下一步的operations。
2. Click on the 'Workflow' tile. The tile has the text 'Workflow' and is located in the grid of application tiles.
3. Wait for the Workflow page to load.
4. Locate the 'Task Management' dropdown menu (it's a button or dropdown with the text 'Task Management'). Click on it to expand the options.
5. From the expanded dropdown, click on 'Initiate Task'.
6. Wait for the processes page to load.
7. On the left sidebar, find the 'Category' section. Click on 'Travel And Expense' to filter the processes.
8. In the processes list, click on 'New Employee Expense Claim'.
9. Wait for the expense claim form to load.
10. Click on the 'Add Expense Claim Item' button.
11. Wait for the 'Add Expense Claim Item' form to load.
12. Click on the 'Account' dropdown field to open the options.
13. Select one of the account options (e.g., '2609 - Other expenses for domestic travel and local travel...') from the dropdown.

Each step must be explicit, no assumptions. For example, when clicking the 'Workflow' tile, we need to specify that it's the tile with the text 'Workflow'. When clicking 'Initiate Task', it's the option in the dropdown. When selecting 'Travel And Expense', it's the category in the left sidebar.
Also, note that some pages have loading states, so we need to wait for them to complete before interacting with elements.
"""

# 提及playwright 
SYSTEM_PROMPT = (
"""
You are an expert in writing robust, asynchronous web automation scripts using Python and Playwright. When generating code, you must adhere to the following core logic and methodologies:

1. Page Loading and Synchronization
After any action that causes page navigation (e.g., `goto`, `click`), you must wait for the page to be fully loaded and stable before proceeding. The preferred method is to wait for the network to become idle:
`await page.wait_for_load_state("networkidle")`

2. Proactive Debugging and State Capture
To help with debugging when elements are not found, ALWAYS include these helper functions and use them strategically:

```python
async def capture_debug_info(page, step_name):
    \"\"\"Capture screenshot and HTML for debugging purposes\"\"\"
    try:
        # Ensure we're working with the most recent/active page
        current_page = await get_current_active_page(page.context)
        
        # Take screenshot from the current active page
        screenshot_path = f"debug_{step_name}_{int(time.time())}.png"
        await current_page.screenshot(path=screenshot_path, full_page=True)
        print(f"Screenshot saved: {screenshot_path}")
        
        # Save HTML content from the current active page as .txt file
        html_path = f"debug_{step_name}_{int(time.time())}.txt"
        content = await current_page.content()
        with open(html_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"HTML content saved as text: {html_path}")
        
        return screenshot_path, html_path
    except Exception as e:
        print(f"Failed to capture debug info: {e}")
        return None, None

async def get_current_active_page(context):
    \"\"\"Get the most recently created/active page from browser context\"\"\"
    pages = context.pages
    if pages:
        # Return the last page (most recently created)
        return pages[-1]
    else:
        # Fallback: create a new page if none exist
        return await context.new_page()

async def safe_wait_and_click(page, selector, step_description, timeout=30000):
    \"\"\"Safely wait for element and click with debugging\"\"\"
    try:
        # Always work with the current active page
        current_page = await get_current_active_page(page.context)
        
        print(f"Looking for: {step_description}")
        element = current_page.locator(selector).first
        await element.wait_for(state='visible', timeout=timeout)
        await element.click()
        print(f"Successfully clicked: {step_description}")
        
        # After clicking, wait a moment for any potential navigation
        await asyncio.sleep(1)
        
        # Update the page reference to the most current one after click
        new_current_page = await get_current_active_page(page.context)
        if new_current_page != current_page:
            print(f"New page detected after clicking {step_description}")
        
        return True, new_current_page
    except Exception as e:
        print(f"Failed to find/click {step_description}: {e}")
        # Capture debug info from the current active page
        current_page = await get_current_active_page(page.context)
        await capture_debug_info(current_page, step_description.replace(' ', '_').lower())
        return False, current_page
```

3. Enhanced Element Interaction Strategy
Always use the safe_wait_and_click function for critical interactions. Set reasonable timeouts (10-20 seconds) and capture debug info when elements are not found.

4. Error Handling and Recovery
Wrap each major step in try-catch blocks and capture debug information on failures:

```python
try:
    success = await safe_wait_and_click(page, "selector", "step description")
    if not success:
        print("Step failed, but continuing...")
        # Continue with next steps or exit gracefully
except Exception as e:
    print(f"Critical error: {e}")
    await capture_debug_info(page, "critical_error")
    raise
```

5. Element Locator Strategy
Prioritize stable, user-facing locators:
* For simple elements, use text-based locators like `get_by_text()`.
* For complex elements, combine CSS selectors with text content: `locator('button:has-text("Some Text")')`
* Always use `.first` to get the first matching element

6. Timeout Management
Set shorter timeouts (15-30 seconds) for individual elements to avoid long waits. This allows faster detection of missing elements and quicker debug info capture.

7. Mandatory Template Structure
ALWAYS use this template structure and CRITICAL page management logic:

```python
from playwright.async_api import async_playwright, TimeoutError
import asyncio
import time

async def capture_debug_info(page, step_name):
    # [Include the enhanced debug function that works with current active page]

async def get_current_active_page(context):
    # [Include the function to get the most recent/active page]

async def safe_wait_and_click(page, selector, step_description, timeout=30000):
    # [Include the enhanced safe click function that returns updated page reference]

async def run(playwright):
    browser = await playwright.chromium.launch(headless=False)
    context = await browser.new_context()
    page = await context.new_page()
    
    try:
        # CRITICAL: Always update page reference after operations that might open new tabs
        # Example pattern:
        success, page = await safe_wait_and_click(page, "selector", "description")
        if success:
            # Always work with the most current page
            page = await get_current_active_page(context)
            await page.wait_for_load_state("networkidle")
        
        # Your automation steps here using the updated pattern
        
    except Exception as e:
        print(f"Script failed: {e}")
        # Always capture from the current active page
        current_page = await get_current_active_page(context)
        await capture_debug_info(current_page, "final_error")
    finally:
        await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)

if __name__ == "__main__":
    asyncio.run(main())
```

8. Page Reference Management (CRITICAL)
- After EVERY click operation that might navigate or open new tabs, update your page reference
- Always use `page = await get_current_active_page(context)` to ensure you're working with the latest page
- The safe_wait_and_click function now returns both success status AND updated page reference
- ALWAYS capture debug info from the current active page, not the original page

9. File Saving Requirements
- HTML content must be saved as .txt files, not .html files
- Always save from the current active page to get the latest content

10. Only return code snippets, do not include any other natural language info
"""
)


def call_gpt4o(messages):
    """调用GPT-4o模型生成代码。"""
    payload = {"messages": messages}
    response = requests.post(API_URL, headers=HEADERS, json=payload)
    response.raise_for_status()
    return response.json()["choices"][0]["message"]["content"]

def call_gpt4o_error_analyzer(script_content, error_info, stdout, stderr):
    """调用GPT-4o模型分析报错信息并给出修复建议。"""
    print("[主进程] 正在分析报错信息...")
    
    #设置prompt
    error_analysis_prompt = f"""
你是一个代码调试专家。请分析以下Python脚本的执行错误，并给出详细的修复建议。

```python
{script_content}
```

执行结果:
- 标准输出 (stdout): {stdout}
- 标准错误 (stderr): {stderr}

请分析错误原因并提供：
原始脚本内容:
```python
{script_content}
```

执行结果:
- 标准输出 (stdout): {stdout}
- 标准错误 (stderr): {stderr}

请分析错误原因并提供：
1. 错误的根本原因
2. 具体的修复建议
3. 需要修改的代码部分
4. 修复后的完整代码

请确保修复后的代码能够正确处理Playwright自动化中的常见问题，如元素定位、页面加载等待等。
"""
    
    #调用
    messages = [
        {"role": "system", "content": "你是一个Python和Playwright自动化专家，擅长分析和修复代码错误。"},
        {"role": "user", "content": error_analysis_prompt}
    ]
    
    return call_gpt4o(messages)


def clean_code_block(code):
    """清理从LLM返回的代码块。"""
    code = code.strip()
    if code.startswith('```'):
        lines = code.splitlines()
        if lines[0].startswith('```'):
            lines = lines[1:]
        if lines and lines[-1].strip() == '```':
            lines = lines[:-1]
        return '\n'.join(lines)
    return code


def run_script_in_subprocess(script_path):
    """
    在一个独立的、隔离的子进程中安全地运行Python脚本 (gpt4o_demo_loop.py) 。
    这是确保主进程不受影响的核心。
    """
    print(f"\n[主进程] 准备在新的子进程中执行脚本: '{script_path}'...")
    try:
        # `subprocess.run` 会启动一个全新的、与主进程隔离的进程。
        # 即使子进程因为内部错误（如ZeroDivisionError, Playwright超时等）而崩溃，
        # 主进程也只会收到一个返回结果，自身不会受到任何影响。
        result = subprocess.run(
            [sys.executable, script_path],  # 使用与主进程相同的Python解释器
            capture_output=True,            # 关键：捕获子进程的所有输出（标准输出和标准错误）
            text=True,                      # 将捕获的输出解码为字符串
            timeout=90                      # 设置超时（秒），更短的超时以便快速检测卡住的情况
        )

        # 无论子进程成功（returncode=0）还是失败（returncode!=0），
        # `subprocess.run`都会正常返回一个CompletedProcess对象。
        # 主进程可以安全地检查这个对象来判断子进程的执行情况。
        if result.returncode == 0:
            print(f"[主进程] 子进程 '{script_path}' 执行成功。")
        else:
            print(f"[主进程] 子进程 '{script_path}' 执行失败，返回码: {result.returncode}。")
        
        return result.returncode, result.stdout, result.stderr

    except subprocess.TimeoutExpired:
        # 如果子进程运行超时，主进程会捕获此异常，但不会崩溃。
        error_msg = f"子进程执行超时（超过 {90} 秒）。可能卡在等待某个元素加载。"
        print(f"[主进程] {error_msg}")
        return -1, "", error_msg
    except Exception as e:
        # 捕获其他启动子进程时可能发生的错误（如文件找不到）。
        error_msg = f"启动子进程时发生未知错误: {e}"
        print(f"[主进程] {error_msg}")
        return -1, "", error_msg


def should_use_glm_analysis(stderr, stdout):
    """
    判断是否应该使用GLM4.5V进行视觉分析。
    返回True表示需要GLM分析（通常是元素定位问题），
    返回False表示需要GPT-4o代码分析（通常是逻辑错误）。
    """
    # 将stderr和stdout合并进行分析
    combined_output = (stderr + "\n" + stdout).lower()
    
    # 需要GLM视觉分析的情况：
    # 1. 元素定位超时或找不到
    # 2. 页面加载问题
    # 3. 截图或页面dump已生成（说明脚本运行到了某个步骤但卡住了）
    # 4. 子进程执行超时（通常表示卡在等待元素）
    glm_indicators = [
        "timeout",
        "element not found", 
        "selector not found",
        "wait_for_selector",
        "error_screenshot.png",
        "error_page_dump.txt",
        "screenshot.png",
        "page_dump.txt", 
        "debug_",
        ".txt",
        "element is not visible",
        "element is not attached",
        "waiting for selector",
        "looking for",
        "子进程执行超时",
        "可能卡在等待某个元素加载"
    ]
    
    # 需要GPT-4o代码分析的情况：
    # 1. 语法错误
    # 2. 导入错误  
    # 3. 运行时逻辑错误
    # 4. API调用错误
    gpt_indicators = [
        "syntaxerror",
        "importerror",
        "modulenotfounderror", 
        "nameerror",
        "attributeerror",
        "typeerror",
        "valueerror",
        "indentationerror",
        "keyerror",
        "indexerror",
        "zerodivisionerror",
        "filenotfounderror"
    ]
    
    # 检查是否有代码逻辑错误
    has_code_error = any(indicator in combined_output for indicator in gpt_indicators)
    
    # 检查是否有元素定位问题
    has_locator_issue = any(indicator in combined_output for indicator in glm_indicators)
    
    # 如果有明确的代码错误，优先使用GPT-4o
    if has_code_error:
        print("[主进程] 检测到代码逻辑错误，将使用GPT-4o进行分析")
        return False
    
    # 如果有元素定位问题，使用GLM4.5V
    if has_locator_issue:
        print("[主进程] 检测到元素定位或页面问题，将使用GLM4.5V进行视觉分析")
        return True
    
    # 默认情况：如果输出为空或无法判断，优先使用GPT-4o
    print("[主进程] 无法明确判断错误类型，默认使用GPT-4o进行分析")
    return False


def feedback_loop():
    """主反馈循环，协调代码生成、执行和分析。"""
    max_iterations = 5  # 最大迭代次数
    iteration = 0
    
    # 1. 生成初始代码
    print("[主进程] 第1步: 生成初始脚本...")
    messages = [
        {"role": "system", "content": SYSTEM_PROMPT},
        {"role": "user", "content": f"Prompt: {CODING_PROMPT}"}
    ]
    
    while iteration < max_iterations:
        iteration += 1
        print(f"\n{'='*50}")
        print(f"开始第 {iteration} 次迭代")
        print(f"{'='*50}")
        
        # 生成或更新代码
        code = call_gpt4o(messages)
        code_clean = clean_code_block(code)
        
        script_path = "gpt4o_demo_loop.py"
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(code_clean)
        print(f"[主进程] 脚本已保存到 '{script_path}'。")

        # 在隔离的子进程中执行脚本
        ret, out, err = run_script_in_subprocess(script_path)
        
        print(f"\n[主进程] 第 {iteration} 次迭代执行完毕，返回码: {ret}")
        
        # 判断执行是否成功
        if ret == 0 and not err.strip():
            print(f"[主进程] 脚本执行成功！在第 {iteration} 次迭代中完成任务。")
            
            # 成功时，仍然可以使用GLM4.5V进行最终验证（如果有截图的话）
            glm_feedback = "脚本执行成功，无需GLM分析。"
            screenshot_path = "screenshot.png"
            if os.path.exists(screenshot_path):
                print("[主进程] 检测到截图，使用GLM4.5V进行最终验证...")
                glm_feedback = analyze_image_with_glm45v(screenshot_path, CODING_PROMPT)
            
            return {
                "success": True,
                "iteration": iteration,
                "return_code": ret,
                "stdout": out,
                "stderr": err,
                "final_script": code_clean,
                "glm_feedback": glm_feedback
            }
        else:
            # 执行失败，根据错误类型选择分析方法
            print(f"[主进程] 脚本执行失败，开始错误分析...")
            
            # 判断应该使用GLM还是GPT-4o进行分析
            use_glm = should_use_glm_analysis(err, out)
            
            if use_glm:
                # 使用GLM4.5V进行视觉分析（元素定位问题）
                print("[主进程] 查找最新的调试文件进行GLM分析...")
                
                # 查找最新的调试截图文件
                analysis_image = None
                debug_files = [f for f in os.listdir('.') if f.startswith('debug_') and f.endswith('.png')]
                if debug_files:
                    # 按文件名排序，获取最新的
                    debug_files.sort(reverse=True)
                    analysis_image = debug_files[0]
                    print(f"[主进程] 使用最新的调试截图进行GLM分析: {analysis_image}")
                else:
                    # 回退到检查常规截图文件
                    if os.path.exists("error_screenshot.png"):
                        analysis_image = "error_screenshot.png"
                        print(f"[主进程] 使用错误截图进行GLM分析: {analysis_image}")
                    elif os.path.exists("screenshot.png"):
                        analysis_image = "screenshot.png"
                        print(f"[主进程] 使用常规截图进行GLM分析: {analysis_image}")
                
                # 查找最新的HTML源码文件(.txt格式)
                html_content = ""
                debug_txt_files = [f for f in os.listdir('.') if f.startswith('debug_') and f.endswith('.txt')]
                if debug_txt_files:
                    debug_txt_files.sort(reverse=True)
                    latest_html_file = debug_txt_files[0]
                    try:
                        with open(latest_html_file, 'r', encoding='utf-8') as f:
                            html_content = f.read()
                        print(f"[主进程] 读取最新的HTML源码: {latest_html_file}")
                    except Exception as e:
                        print(f"[主进程] 读取HTML文件失败: {e}")
                
                if analysis_image:
                    # 构造更详细的prompt，包含HTML源码信息
                    enhanced_prompt = f"""
{CODING_PROMPT}

当前页面的HTML源码信息：
{html_content[:2000] if html_content else "无HTML源码信息"}
...

请分析截图中的页面状态，特别关注：
1. 当前页面是否正确加载
2. 目标元素是否可见
3. 页面布局和元素位置
4. 可能的错误提示或加载状态
"""
                    
                    glm_feedback = analyze_image_with_glm45v(analysis_image, enhanced_prompt)
                    print(f"[主进程] GLM分析完成")
                    
                    # 将GLM的分析结果传递给GPT-4o来生成修复代码
                    analysis_content = f"""
基于视觉分析的反馈：

GLM4.5V视觉分析结果：
{glm_feedback}

最新HTML源码文件: {debug_txt_files[0] if debug_txt_files else "未找到"}
HTML内容预览: {html_content[:500] if html_content else "无内容"}...

执行输出信息：
- 返回码: {ret}
- 标准输出: {out}
- 标准错误: {err}

请根据GLM的视觉分析结果和执行信息，修复脚本中的元素定位和页面交互问题。
"""
                else:
                    # 没有截图，回退到GPT-4o分析
                    print("[主进程] 没有找到截图文件，回退到GPT-4o代码分析")
                    analysis_content = call_gpt4o_error_analyzer(code_clean, f"返回码: {ret}", out, err)
            else:
                # 使用GPT-4o进行代码错误分析
                print("[主进程] 使用GPT-4o进行代码错误分析")
                analysis_content = call_gpt4o_error_analyzer(code_clean, f"返回码: {ret}", out, err)
            
            print(f"\n[主进程] 错误分析完成，准备下一次迭代...")
            
            # 准备下一次迭代的消息
            messages.append({"role": "assistant", "content": code})
            messages.append({
                "role": "user", 
                "content": f"""
脚本执行失败，以下是分析结果：

{analysis_content}

请根据分析结果，修复脚本中的问题并重新生成完整的代码。确保：
1. 修复所有识别出的错误
2. 改进元素定位策略
3. 增强页面加载等待逻辑
4. 处理可能的异常情况

请直接提供修复后的完整Python脚本代码。
"""
            })
    
    # 达到最大迭代次数仍未成功
    print(f"\n[主进程] 达到最大迭代次数 ({max_iterations})，未能成功执行脚本。")
    return {
        "success": False,
        "iteration": iteration,
        "return_code": ret,
        "stdout": out,
        "stderr": err,
        "final_script": code_clean,
        "message": "达到最大迭代次数，未能修复所有错误"
    }

if __name__ == "__main__":
    feedback_loop()
